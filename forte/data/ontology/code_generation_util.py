# Copyright 2019 The Forte Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import os
from collections import OrderedDict
from typing import List, Optional, Any


class Config:
    indent: int = 4
    line_break: str = os.linesep


def indent(level: int) -> str:
    return ' ' * Config.indent * level


def indent_line(line: str, level: int) -> str:
    return f"{indent(level)}{line}" if line else ''


def indent_code(code_lines: List[str], level: int = 0) -> str:
    lines = []
    for code in code_lines:
        lines.extend(code.split(Config.line_break) if code is not None else [])
    return Config.line_break.join([indent_line(line, level) for line in lines])


def empty_lines(num: int):
    return ''.join([Config.line_break] * num)


class Item:
    def __init__(self, name: str, description: Optional[str]):
        self.name: str = name
        self.description: Optional[str] = description

    def to_description(self, level: int) -> Optional[str]:
        if self.description is not None:
            return indent_code([self.description], level)
        return None

    def to_code(self, level: int) -> str:
        raise NotImplementedError


class Property(Item):
    def __init__(self,
                 name: str,
                 type_str: str,
                 description: Optional[str] = None,
                 default: Any = None):
        super().__init__(name, description)
        self.type_str = type_str
        self.default = default

    def to_getter_setter_code(self, level) -> str:
        """
            Returns: getter and setter functions generated by a property.
        """
        name = self.name
        lines = [("@property", 0),
                 (f"def {name}(self):", 0),
                 (f"return self._{name}", 1),
                 (empty_lines(0), 0),
                 (f"def set_{name}(self, {name}: {self.to_code(0)}):", 0),
                 (f"self._{name} = {name}", 1),
                 (empty_lines(0), 0)]
        return indent_code([indent_line(*line) for line in lines], level)

    def to_init_code(self, level: int) -> str:
        return indent_line(f"self._{self.name}: {self.to_code(0)} = "
                           f"{repr(self.default)}", level)

    def to_description(self, level: int) -> Optional[str]:
        if self.description is not None and self.description.strip() != '':
            return indent_line(f"{self.name} ({self.to_code(0)}): "
                               f"{self.description}", level)
        return None


class BasicItem(Property):
    TYPES = {'int', 'float', 'str', 'bool'}

    def __init__(self,
                 name: str,
                 type_str: str,
                 description: Optional[str] = None,
                 default: Any = None):
        super().__init__(name, type_str, description, default)
        self.type_str = type_str

    def to_code(self, level: int = 0) -> str:
        return f"typing.Optional[{self.type_str}]"


class CompositeItem(Property):
    TYPES = {'List'}

    def __init__(self,
                 name: str,
                 type_str: str,
                 items: List[str],
                 description: Optional[str] = None,
                 default: Any = None):
        super().__init__(name, type_str, description, default)
        self.items = items

    def to_code(self, level: int = 0) -> str:
        items = list(OrderedDict([(item, None) for item in self.items]).keys())
        item_type_str = f"{', '.join(items)}"

        if len(self.items) > 1:
            item_type_str = f"typing.Union[{item_type_str}]"

        return f"typing.Optional[{self.type_str}[{item_type_str}]]"


class DefinitionItem(Item):
    def __init__(self, name: str,
                 class_type: str,
                 init_args: Optional[str] = None,
                 properties: Optional[List[Property]] = None,
                 description: Optional[str] = None):
        super().__init__(name, description)
        self.class_type = class_type
        self.properties: List[Property] = \
            [] if properties is None else properties
        self.description = description if description else None
        self.init_args = init_args if init_args is not None else ''

    def to_init_code(self, level: int) -> str:
        return indent_line(f"def __init__(self, {self.init_args}):", level)

    def to_code(self, level: int) -> str:
        super_args = ', '.join([item.split(':')[0].strip()
                                for item in self.init_args.split(',')])
        lines = [
            empty_lines(1),
            f"__all__.extend('{self.name}')",
            empty_lines(1),
            f"class {self.name}({self.class_type}):",
            self.to_description(1),
            self.to_init_code(1),
            indent_line(f"super().__init__({super_args})", 2)
        ]
        lines += [item.to_init_code(2) for item in self.properties]
        lines.append(empty_lines(0))
        lines += [item.to_getter_setter_code(1) for item in self.properties]

        return indent_code(lines, level)

    def to_description(self, level: int) -> Optional[str]:
        class_desc = [] if self.description is None else [self.description]
        item_descs = [item.to_description(0) for item in self.properties]
        item_descs = [item for item in item_descs if item is not None]
        item_descs = [indent_line('Args:', 1)] + \
                     [indent_line(desc, 2) for desc in item_descs]
        if len(class_desc) == 0 and len(item_descs) == 0:
            return ""
        quotes = indent_line('"""', 0)
        return indent_code([quotes] + class_desc + item_descs + [quotes], level)


class FileItem:
    def __init__(self,
                 entry_item: DefinitionItem,
                 entry_file: str,
                 ignore_errors: Optional[List[str]],
                 description: Optional[str],
                 imports: Optional[List[str]]):
        self.description = description
        self.ignore_errors = [] if not ignore_errors else ignore_errors
        self.imports = [] if not imports else imports
        self.entry_item = entry_item
        self.entry_file_exists = os.path.exists(entry_file)

    def to_code(self, level: int) -> str:
        lines: List[str] = []
        if not self.entry_file_exists:
            lines = [self.to_description(0),
                     self.to_import_code(0),
                     empty_lines(1), '__all__ = []']
        lines.append(self.entry_item.to_code(0))
        return indent_code(lines, level)

    def to_description(self, level):
        quotes = '"""'
        lines = self.ignore_errors + [quotes, self.description, quotes]
        return indent_code(lines, level)

    def to_import_code(self, level):
        imports_set: OrderedDict[str] = {}
        for import_ in self.imports:
            imports_set[f"import {import_}"] = None
        return indent_code(list(imports_set), level)
