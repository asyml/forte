"""
    Module to generate ontology
"""
import json
import os


class GenerateOntology:
    """
    Class to generate a python ontology file given ontology in json format
    """
    def __init__(self, json_file_path):
        self.json_file_path = json_file_path

    def generate_ontology(self):
        """
        Function to generate and save the python ontology code after reading
        ontology from self.json_file_path
        Returns: Path of python ontology file if the code executes correctly
        else None
        """
        with open(self.json_file_path, 'r') as f:
            json_string = f.read()
        ontology = json.loads(json_string)
        ontology_full_name = ontology["ontology_name"]
        imports = ontology["imports"]
        entry_definitions = ontology["entry_definitions"]

        ontology_file_path, ontology_code \
            = self.get_code_ontology_name(ontology_full_name)

        for import_module in imports:
            ontology_code += f"import {import_module}\n"

        for entry_definition in entry_definitions:
            ontology_code += self.get_code_entry(entry_definition)

        try:
            exec(ontology_code)
            with open(ontology_file_path, 'w') as f:
                f.write(ontology_code)
            return ontology_file_path
        except Exception as e:
            print(f"Not able to execute the generated code, "
                  f"got exception message {e}")
            return None

    def get_code_ontology_name(self, ontology_full_name):
        """
        Function to parse ontology package and name, create required folders
        if the ontology package is not the same as current package, and generate
        corresponding code
        Args:
            ontology_full_name: Full namespace of the ontology

        Returns: Directory name where the generated file would be stored and
        the generated code
        """
        namespace = ontology_full_name.split('.')
        ontology_package = '.'.join(namespace[0:-1])
        ontology_package_folder = '/'.join(namespace[0:-1])
        ontology_name = namespace[-1]
        code_str = f"import {ontology_package}\n"
        curr_package = '.'.join(__name__.split('.')[0:-1])
        if curr_package == ontology_package:
            ontology_dir_path = os.path.dirname(__file__)
        else:
            ontology_dir_path = os.path.join(os.path.dirname(__file__),
                                             ontology_package_folder)
            os.makedirs(ontology_dir_path)
        ontology_file_path = os.path.join(ontology_dir_path,
                                          ontology_name + '.py')
        return ontology_file_path, code_str

    def get_code_entry(self, entry_definition):
        """
        Args:
            entry_definition: entry definition dictionary

        Returns: code generated by an entry definition
        """
        entry_name = entry_definition["entry_name"].split('.')[-1]
        parent_entry = entry_definition["parent_entry"]
        instance_attributes = entry_definition["attributes"] \
            if "attributes" in entry_definition else []
        class_attributes = entry_definition["class_attributes"] \
            if "class_attributes" in entry_definition else []
        entry_code = \
            f"\n\nclass {entry_name}({parent_entry}):\n" \
            f"\tdef __init__(self, *args):\n" \
            f"\t\tsuper().__init__(args)\n"

        for attribute in instance_attributes:
            attribute_code = self.get_code_attribute(attribute,
                                                     is_class_attribute=False)
            entry_code += f"{attribute_code}"

        for attribute in class_attributes:
            attribute_code = self.get_code_attribute(attribute,
                                                     is_class_attribute=True)
            entry_code += f"{attribute_code}"

        return entry_code

    def get_code_attribute(self, attribute, is_class_attribute=False):
        """
        Args:
            attribute: Dictionary corresponding to a single attribute for an
            entry
            is_class_attribute: whether the attribute is a class variable
            or instance variable

        Returns: code generated by an attribute

        """
        attribute_name = attribute["attribute_name"]
        attribute_type = attribute["attribute_type"]

        if "attribute_default_value" in attribute and \
                attribute["attribute_default_value"] is not None:
            attribute_default_value = attribute["attribute_default_value"]
            if attribute_type == "str":
                attribute_default_value = f"'{attribute_default_value}'"
        else:
            attribute_default_value = "None"

        code_string = f"{attribute_name}: Optional[{attribute_type}] " \
            f"= {attribute_default_value}"

        if not is_class_attribute:
            return f'\t\tself.{code_string}\n'
        else:
            return f'\t{code_string}\n'
