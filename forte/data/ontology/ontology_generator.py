"""
    Module to generate python ontology
"""
import json
import os
import shutil

from typing import Dict, Tuple, List


class OntologyGenerator:
    """
    Class to generate a python ontology file given ontology in json format
    Example:
        >>> _, generated_file, _ = OntologyGenerator().generate_ontology(
        'test/example_ontology.json')
        >>> assert open(generated_file, 'r').read() == \
                   open('test/true_example_ontology.py', 'r').read()
    """

    # string constants
    _ONTOLOGY_NAME = "ontology_name"
    _IMPORTS = "imports"
    _ENTRY_DEFINITIONS = "entry_definitions"
    _ENTRY_NAME = "entry_name"
    _PARENT_ENTRY = "parent_entry"
    _ATTRIBUTES = "attributes"
    _ATTRIBUTE_NAME = "attribute_name"
    _ATTRIBUTE_TYPE = "attribute_type"
    _ATTRIBUTE_DEFAULT_VALUE = "attribute_default_value"
    
    _INDENT = ' ' * 4

    def __init__(self):
        # mapping from ontology full name to corresponding generated file and
        # folder path
        self._generated_ontology_record: Dict[str, Tuple[str, str]] = {}

    def generate_ontology(self, json_file_path):
        """
        Function to generate and save the python ontology code after reading
        ontology from self.json_file_path
        Returns: Path of python ontology file if the code executes correctly
        else None
        """
        with open(json_file_path, 'r') as f:
            json_string: str = f.read()
            ontology: dict = json.loads(json_string)
            ontology_full_name: str = ontology[self._ONTOLOGY_NAME]
            imports: List[str] = ontology[self._IMPORTS]
            entry_definitions: List[str] = ontology[self._ENTRY_DEFINITIONS]

            ontology_file_docstring = '"""\nAutomatically generated file. ' \
                                      'Do not change by hand.\n"""'

            ontology_code, ontology_folder, ontology_file_name \
                = self.get_code_ontology_name(ontology_full_name)

            ontology_code = f"{ontology_file_docstring}\n" \
                            f"import typing\n" \
                            f"{ontology_code}"

            ontology_dir_path = os.path.join(os.getcwd(), ontology_folder)
            if not os.path.isdir(ontology_dir_path):
                os.makedirs(ontology_dir_path)

            ontology_file_path = os.path.join(ontology_dir_path,
                                              ontology_file_name)

            for import_module in imports:
                ontology_code += f"import {import_module}\n"

            for entry_definition in entry_definitions:
                ontology_code += self.get_code_entry(entry_definition)

            with open(ontology_file_path, 'w') as file:
                file.write(ontology_code)

            self._generated_ontology_record[ontology_full_name] \
                = (ontology_file_path, ontology_folder)

            return ontology_full_name, ontology_file_path, ontology_folder

    def cleanup_generated_ontology(self, ontology_full_name):
        """
        Deletes the generated ontology file and corresponding folder if empty
        Args:
            ontology_full_name: Full name of the ontology (with package name)
        """
        if ontology_full_name in self._generated_ontology_record:
            ontology_file_path, ontology_folder = \
                self._generated_ontology_record[ontology_full_name]

            # delete generated file
            os.remove(ontology_file_path)

            # delete generated folders
            top_path = os.path.join(os.getcwd(), ontology_folder.split('/')[0])
            all_files = [files for _, _, files in os.walk(top_path)]
            num_files = sum([len(files) for files in all_files])
            if num_files == 0:
                shutil.rmtree(top_path)

    def get_code_ontology_name(self, ontology_full_name):
        """
        Function to parse ontology package and name, create required folders
        if the ontology package is not the same as current package, and generate
        corresponding code
        Args:
            ontology_full_name: Full namespace of the ontology

        Returns:
            - The generated code
            - Directory path where the generated file would be stored
            - Name of the file to be generated
        """
        namespace = ontology_full_name.split('.')
        ontology_package = '.'.join(namespace[0:-1])
        code_str = f"import {ontology_package}\n"

        ontology_folder = os.path.join(*namespace[0:-1])
        ontology_file_name = namespace[-1] + '.py'

        return code_str, ontology_folder, ontology_file_name

    def get_code_entry(self, entry_definition):
        """
        Args:
            entry_definition: entry definition dictionary

        Returns: code generated by an entry definition
        """
        entry_name = entry_definition[self._ENTRY_NAME].split('.')[-1]
        parent_entry = entry_definition[self._PARENT_ENTRY]
        instance_attributes = entry_definition[self._ATTRIBUTES] \
            if self._ATTRIBUTES in entry_definition else []
        entry_code = \
            f"\n\nclass {entry_name}({parent_entry}):\n" \
            f"{self._INDENT}def __init__(self, *args, **kwargs):\n" \
            f"{self._INDENT}{self._INDENT}super().__init__(*args, **kwargs)\n"

        for attribute in instance_attributes:
            attribute_code = self.get_code_attribute(attribute)
            entry_code += f"{attribute_code}"

        return entry_code

    def get_code_attribute(self, attribute):
        """
        Args:
            attribute: Dictionary corresponding to a single attribute
            for an entry

        Returns: code generated by an attribute

        """
        attribute_name = attribute[self._ATTRIBUTE_NAME]
        attribute_type = attribute[self._ATTRIBUTE_TYPE]

        if self._ATTRIBUTE_DEFAULT_VALUE in attribute and \
                attribute[self._ATTRIBUTE_DEFAULT_VALUE] is not None:
            attribute_default_value = attribute[self._ATTRIBUTE_DEFAULT_VALUE]
            if attribute_type == "str":
                attribute_default_value = f"'{attribute_default_value}'"
        else:
            attribute_default_value = "None"

        code_string = f"{self._INDENT}{attribute_name}: " \
            f"typing.Optional[{attribute_type}] = {attribute_default_value}\n"

        return code_string
