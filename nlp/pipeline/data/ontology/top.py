from abc import abstractmethod
from functools import total_ordering
from typing import Iterable, Optional, Set, Union, Type, TypeVar

from nlp.pipeline.utils import get_class_name, get_full_module_name
from nlp.pipeline import config

__all__ = [
    "Span",
    "Entry",
    "EntryType",
    "Annotation",
    "Link",
    "Group"
]


@total_ordering
class Span:
    """
    A class recording the span of annotations. :class:`Span` objects can
    be totally ordered according to their :attr:`begin` as the first sort key
    and :attr:`end` as the second sort key.

    Args:
        begin (int): The offset of the first character in the span.
        end (int): The offset of the last character in the span + 1. So the
            span is a left-closed and right-open interval ``[begin, end)``.
    """

    def __init__(self, begin: int, end: int):
        self.begin = begin
        self.end = end

    def __lt__(self, other):
        if self.begin == other.begin:
            return self.end < other.end
        return self.begin < other.begin

    def __eq__(self, other):
        return (self.begin, self.end) == (other.begin, other.end)


class Entry:
    """The base class inherited by all NLP entries."""

    def __init__(self):
        self.component = config.working_component
        self._tid: Optional[str] = None
        self._data_pack = None

    @property
    def tid(self):
        return self._tid

    def set_tid(self, tid: str):
        """
        Set the entry id.

        To avoid duplicate, we use the full module path and class name as the
        prefix of ``tid``. A pack-level unique ``tid`` is automatically
        assigned when you add an entry to a pack, so users are **not** suggested
        to set ``tid`` directly.
        """
        self._tid = f"{get_full_module_name(self)}.{tid}"

    @property
    def data_pack(self):
        return self._data_pack

    def attach(self, data_pack):
        """
        Attach the entry itself to a data_pack.

        An entry is automatically attached to a pack when you add the entry to
        the pack, so users are **not** suggested to call this function directly.
        """
        self._data_pack = data_pack

    def set_fields(self, **kwargs):
        """
        Set other entry fields.
        """
        for field_name, field_value in kwargs.items():
            if not hasattr(self, field_name):
                raise AttributeError(
                    f"class {get_class_name(self)} "
                    f"has no attribute {field_name}"
                )
            setattr(self, field_name, field_value)

    @abstractmethod
    def hash(self):
        """
        The hash function for :class:`Entry` objects.
        To be implemented in each subclass.
        """
        raise NotImplementedError

    @abstractmethod
    def eq(self, other):
        """
        The eq function for :class:`Entry` objects.
        To be implemented in each subclass.
        """
        raise NotImplementedError

    def __hash__(self):
        return self.hash()

    def __eq__(self, other):
        return self.eq(other)


EntryType = TypeVar('EntryType', bound=Entry)


@total_ordering
class Annotation(Entry):
    """
    Annotation type entries, such as "token", "entity mention" and
    "sentence". Each annotation has a :class:`Span` corresponding to its offset
    in the text.

    Args:
        begin (int): The offset of the first character in the annotation.
        end (int): The offset of the last character in the annotation + 1.
    """

    def __init__(self, begin: int, end: int):
        super().__init__()
        self._span = Span(begin, end)

    @property
    def span(self):
        return self._span

    def set_span(self, begin: int, end: int):
        """
        Set the span of the annotation.
        """
        if begin > end:
            raise ValueError(
                f"The begin {begin} of span is greater than the end {end}")
        self._span = Span(begin, end)

    def hash(self):
        """
        The hash function of :class:`Annotation`.

        Users can define their own hash function by themselves but this must
        be consistent to :meth:`eq`.
        """
        return hash(
            (self.component, type(self), self.span.begin, self.span.end))

    def eq(self, other):
        """
        The eq function of :class:`Annotation`.
        By default, :class:`Annotation` objects are regarded as the same if
        they have the same type, span, and are generated by the same component.

        Users can define their own eq function by themselves but this must
        be consistent to :meth:`hash`.
        """
        return (type(self), self.component, self.span.begin, self.span.end) == \
               (type(other), other.component, other.span.begin, other.span.end)

    def __lt__(self, other):
        """
        To support total_ordering, :class:`Annotations` must provide
        :meth:`__lt__`.

        Users can define their own lt function by themselves but this must
        be consistent to :meth:`eq`.
        """
        if self.span != other.span:
            return self.span < other.span
        if self.component != other.component:
            return self.component < other.component
        return str(type(self)) < str(type(other))

    @property
    def text(self):
        if self.data_pack is None:
            raise ValueError(f"Cannot get text because annotation is not "
                             f"attached to any data pack.")
        return self.data_pack.text[self.span.begin: self.span.end]


class Link(Entry):
    """
    Link type entries, such as "predicate link". Each link has a parent node
    and a child node.

    Args:
        parent (Entry, optional): the parent entry of the link.
        child (Entry, optional): the child entry of the link.
    """
    parent_type: Type[Entry] = Entry  # type: ignore
    """The entry type of the parent node."""
    child_type: Type[Entry] = Entry  # type: ignore
    """The entry type of the child node."""

    def __init__(self,
                 parent: Optional[Entry] = None,
                 child: Optional[Entry] = None):
        super().__init__()
        self._parent: Optional[str] = None
        self._child: Optional[str] = None
        if parent is not None:
            self.set_parent(parent)
        if child is not None:
            self.set_child(child)

    def hash(self):
        """
        The hash function of :class:`Link`.

        Users can define their own hash function by themselves but this must
        be consistent to :meth:`eq`.
        """
        return hash((self.component, type(self), self.parent, self.child))

    def eq(self, other):
        """
        The eq function of :class:`Link`.
        By default, :class:`Link` objects are regarded as the same if
        they have the same type, parent, child, and are generated by the same
        component.

        Users can define their own eq function by themselves but this must
        be consistent to :meth:`hash`.
        """
        return (type(self), self.component, self.parent, self.child) == \
               (type(other), other.component, other.parent, other.child)

    @property
    def parent(self):
        """
        Get ``tid`` of the parent node. To get the object of the parent node,
        call :meth:`get_parent`.
        """
        return self._parent

    @property
    def child(self):
        """
        Get ``tid`` of the child node. To get the object of the child node,
        call :meth:`get_child`.
        """
        return self._child

    def set_parent(self, parent: Entry):
        """
        Set the parent node of the link.

        Args:
            parent (Entry): the parent entry.
        """
        if not isinstance(parent, self.parent_type):
            raise TypeError(
                f"The parent of {type(self)} should be an "
                f"instance of {self.parent_type}, but get {type(parent)}")

        self._parent = parent.tid

        if (self.data_pack is not None and
                self.data_pack.index.link_index_switch):
            self.data_pack.index.update_link_index(links=[self])

    def set_child(self, child: Entry):
        """
        Set the child node of the link.

        Args:
            child (Entry): the child entry.
        """
        if not isinstance(child, self.child_type):
            raise TypeError(
                f"The parent of {type(self)} should be an "
                f"instance of {self.child_type}, but get {type(child)}")

        self._child = child.tid

        if (self.data_pack is not None and
                self.data_pack.index.link_index_switch):
            self.data_pack.index.update_link_index(links=[self])

    def get_parent(self):
        """
        Get the parent entry of the link.

        Returns:
             An instance of :class:`Entry` that is the parent of the link.
        """
        if self.data_pack is None:
            raise ValueError(f"Cannot get parent because link is not "
                             f"attached to any data pack.")
        return self.data_pack.get_entry_by_id(self._parent)

    def get_child(self):
        """
        Get the child entry of the link.

        Returns:
             An instance of :class:`Entry` that is the child of the link.
        """
        if self.data_pack is None:
            raise ValueError(f"Cannot get child because link is not"
                             f" attached to any data pack.")
        return self.data_pack.get_entry_by_id(self._child)


class Group(Entry):
    """Group type entries, such as "coreference group". Each group has a set
    of members.
    """
    member_type: Type[Entry] = Entry  # type: ignore
    """The entry type of group members."""

    def __init__(self, members: Optional[Set[Entry]] = None):

        super().__init__()
        self._members: Set[str] = set()
        if members is not None:
            self.add_members(members)

    def add_members(self, members: Union[Iterable[Entry], Entry]):
        """
        Add group members.

        Args:
            members (Iterable[Entry] or Entry): either a single member object or
                a set of members to be added into the group.
        """
        if not isinstance(members, Iterable):
            members = {members}

        for member in members:
            if not isinstance(member, self.member_type):
                raise TypeError(
                    f"The members of {type(self)} should be "
                    f"instances of {self.member_type}, but get {type(member)}")

            self._members.add(member.tid)

        if (self.data_pack is not None and
                self.data_pack.index.group_index_switch):
            self.data_pack.index.update_group_index([self])

    @property
    def members(self):
        """
        Return a list of ``tid`` of the group members. To get the
        member objects, call :meth:`get_members` instead.
        """
        return self._members

    def hash(self):
        """
        The hash function of :class:`Group`.

        Users can define their own hash function by themselves but this must
        be consistent to :meth:`eq`.
        """
        return hash((type(self), self.component, tuple(self.members)))

    def eq(self, other):
        """
        The eq function of :class:`Group`.
        By default, :class:`Group` objects are regarded as the same if
        they have the same type, members, and are generated by the same
        component.

        Users can define their own eq function by themselves but this must
        be consistent to :meth:`hash`.
        """
        return (type(self), self.component, self.members) == \
               (type(other), other.component, other.members)

    def get_members(self):
        """
        Get the member entries in the group.

        Returns:
             An set of instances of :class:`Entry` that are the members of the
             group.
        """
        if self.data_pack is None:
            raise ValueError(f"Cannot get members because group is not "
                             f"attached to any data pack.")
        member_entries = set()
        for m in self.members:
            member_entries.add(self.data_pack.get_entry_by_id(m))
        return member_entries
